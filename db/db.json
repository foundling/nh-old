{
  "RegExp": {
    "shortDescription": "There are 2 ways to create a RegExp object: a literal notation and a constructor. To indicate strings, the parameters to the literal notation do not use quotation marks while the parameters to the constructor function do use quotation marks. So the following expressions create the same regular expression:/ab+c/i;\nnew RegExp('ab+c', 'i');\nnew RegExp(/ab+c/, 'i');\nThe literal notation provides compilation of the regular expression when the expression is evaluated. Use literal notation when the regular expression will remain constant. For example, if you use literal notation to construct a regular expression used in a loop, the regular expression won't be recompiled on each iteration.The constructor of the regular expression object, for example, new RegExp('ab+c'), provides runtime compilation of the regular expression. Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.Starting with ECMAScript 6, new RegExp(/ab+c/, 'i') no longer throws a TypeError (\"can't supply flags when constructing one RegExp from another\") when the first argument is a RegExp and the second flags argument is present. A new RegExp from the arguments is created instead.When using the constructor function, the normal string escape rules (preceding special characters with \\ when included in a string) are necessary. For example, the following are equivalent:var re = /\\w+/;\nvar re = new RegExp('\\\\w+');\n",
    "syntax": "/pattern/flags\nnew RegExp(pattern[, flags])\n",
    "prototypeProperties": {
      "RegExp.prototype.constructor": "Specifies the function that creates an object's prototype.",
      "RegExp.prototype.flags  ": "A string that contains the flags of the RegExp object.",
      "RegExp.prototype.global": "Whether to test the regular expression against all possible matches in a string, or only against the first.",
      "RegExp.prototype.ignoreCase": "Whether to ignore case while attempting a match in a string.",
      "RegExp.prototype.multiline": "Whether or not to search in strings across multiple lines.",
      "RegExp.prototype.source": "The text of the pattern.",
      "RegExp.prototype.sticky  ": "Whether or not the search is sticky.",
      "RegExp.prototype.unicode  ": "Whether or not Unicode features are enabled."
    },
    "prototypeMethods": {
      "RegExp.prototype.compile()  ": "(Re-)compiles a regular expression during execution of a script.",
      "RegExp.prototype.exec()": "Executes a search for a match in its string parameter.",
      "RegExp.prototype.test()": "Tests for a match in its string parameter.",
      "RegExp.prototype.toSource()  ": "Returns an object literal representing the specified object; you can use this value to create a new object. Overrides the Object.prototype.toSource() method.",
      "RegExp.prototype.toString()": "Returns a string representing the specified object. Overrides the Object.prototype.toString() method."
    },
    "constructorProperties": {
      "RegExp.prototype": "Allows the addition of properties to all objects.",
      "RegExp.length": "The value of RegExp.length is 2.",
      "RegExp.lastIndex": "The index at which to start the next match."
    },
    "constructorMethods": {}
  },
  "Array": {
    "shortDescription": "Arrays are list-like objects whose prototype has methods to perform traversal and mutation operations. Neither the length of a JavaScript array nor the types of its elements are fixed. Since an array's size length grow or shrink at any time, JavaScript arrays are not guaranteed to be dense. In general, these are convenient characteristics; but if these features are not desirable for your particular use, you might consider using typed arrays.Some people think that you shouldn't use an array as an associative array. In any case, you can use plain objects instead, although doing so comes with its own caveats. See the post Lightweight JavaScript dictionaries with arbitrary keys as an example.",
    "syntax": "[element0, element1, ..., elementN]\nnew Array(element0, element1[, ...[, elementN]])\nnew Array(arrayLength)",
    "prototypeProperties": {
      "Array.prototype.constructor": "Specifies the function that creates an object's prototype.",
      "Array.prototype.length": "Reflects the number of elements in an array."
    },
    "prototypeMethods": {},
    "constructorProperties": {
      "Array.length": "The Array constructor's length property whose value is 1.",
      "Array.prototype": "Allows the addition of properties to all array objects."
    },
    "constructorMethods": {
      "Array.from()  ": "Creates a new Array instance from an array-like or iterable object.",
      "Array.isArray()": "Returns true if a variable is an array, if not false.",
      "Array.observe()  ": "Asynchronously observes changes to Arrays, similar to Object.observe() for objects. It provides a stream of changes in order of occurrence.",
      "Array.of()  ": "Creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments."
    }
  },
  "isNaN": {
    "shortDescription": "The necessity of an isNaN functionUnlike all other possible values in JavaScript, it is not possible to rely on the equality operators (== and ===) to determine whether a value is NaN or not, because both NaN == NaN and NaN === NaN evaluate to false. Hence, the necessity of an isNaN function.Origin of NaN valuesNaN values are generated when arithmetic operations result in undefined or unrepresentable values. Such values do not necessarily represent overflow conditions. A NaN also results from attempted coercion to numeric values of non-numeric values for which no primitive numeric value is available.For example, dividing zero by zero results in a NaN â€” but dividing other numbers by zero does not.Confusing special-case behaviorSince the very earliest versions of the isNaN function specification, its behavior for non-numeric arguments has been confusing. When the argument to the isNaN function is not of type Number, the value is first coerced to a Number. The resulting value is then tested to determine whether it is NaN. Thus for non-numbers that when coerced to numeric type result in a valid non-NaN numeric value (notably the empty string and boolean primitives, which when coerced give numeric values zero or one), the \"false\" returned value may be unexpected; the empty string, for example, is surely \"not a number.\" The confusion stems from the fact that the term, \"not a number\", has a specific meaning for numbers represented as IEEE-754 floating-point values. The function should be interpreted as answering the question, \"is this value, when coerced to a numeric value, an IEEE-754 'Not A Number' value?\"The next version of ECMAScript (ES6) contains the Number.isNaN() function. Number.isNaN(x) will be a reliable way to test whether x is NaN or not. Even with Number.isNaN, however, the meaning of NaN remains the precise numeric meaning, and not simply, \"not a number\". Alternatively, in absense of Number.isNaN, the expression (x != x) is a more reliable way to test whether variable x is NaN or not, as the result is not subject to the false positives that make isNaN unreliable.ExamplesisNaN(NaN);       // true\nisNaN(undefined); // true\nisNaN({});        // true\n\nisNaN(true);      // false\nisNaN(null);      // false\nisNaN(37);        // false\n\n// strings\nisNaN(\"37\");      // false: \"37\" is converted to the number 37 which is not NaN\nisNaN(\"37.37\");   // false: \"37.37\" is converted to the number 37.37 which is not NaN\nisNaN(\"\");        // false: the empty string is converted to 0 which is not NaN\nisNaN(\" \");       // false: a string with spaces is converted to 0 which is not NaN\n\n// dates\nisNaN(new Date());                // false\nisNaN(new Date().toString());     // true\n\n// This is a false positive and the reason why isNaN is not entirely reliable\nisNaN(\"blabla\")   // true: \"blabla\" is converted to a number. \n                  // Parsing this as a number fails and returns NaN\nUseful special-case behaviorThere is a more usage oriented way to think of isNaN(): If isNaN(x) returns false, you can use x in an arithmetic expression not making the expression return NaN. If it returns true, x will make every arithmetic expression return NaN. This means that in JavaScript, isNaN(x) == true is equivalent to x - 0 returning NaN (though in JavaScript x - 0 == NaN always returns false, so you can't test for it). Actually, isNaN(x), isNaN(x - 0), isNaN(Number(x)), Number.isNaN(x - 0), and Number.isNaN(Number(x)) always return the same and in JavaScript isNaN(x) is just the shortest possible form to express each of these terms.You can use this, for example, to test whether an argument to a function is arithmetically processable (usable \"like\" a number), or if it's not and you have to provide a default value or something else. This way you can have a function that makes use of the full versatility JavaScript provides by implicitly converting values depending on context.Examplesfunction increment(x) {\n  if (isNaN(x)) x = 0;\n  return x + 1;\n};\n\n// The same effect with Number.isNaN():\nfunction increment(x) {\n  if (Number.isNaN(Number(x))) x = 0;\n  return x + 1;\n};\n\n// In the following cases for the function's argument x,\n// isNaN(x) is always false, although x is indeed not a\n// number, but can be used as such in arithmetical\n// expressions\nincrement(\"\");            // 1: \"\" is converted to 0\nincrement(new String());  // 1: String object representing an empty string is converted to 0\nincrement([]);            // 1: [] is converted to 0\nincrement(new Array());   // 1: Array object representing an empty array is converted to 0\nincrement(\"0\");           // 1: \"0\" is converted to 0\nincrement(\"1\");           // 2: \"1\" is converted to 1\nincrement(\"0.1\");         // 1.1: \"0.1\" is converted to 0.1\nincrement(\"Infinity\");    // Infinity: \"Infinity\" is converted to Infinity\nincrement(null);          // 1: null is converted to 0\nincrement(false);         // 1: false is converted to 0\nincrement(true);          // 2: true is converted to 1\nincrement(new Date());    // returns current date/time in milliseconds plus 1\n\n// In the following cases for the function's argument x,\n// isNaN(x) is always false and x is indeed a number\nincrement(-1);            // 0\nincrement(-0.1);          // 0.9\nincrement(0);             // 1\nincrement(1);             // 2\nincrement(2);             // 3\n// ... and so on ...\nincrement(Infinity);      // Infinity\n\n// In the following cases for the function's argument x,\n// isNaN(x) is always true and x is really not a number,\n// thus the function replaces it by 0 and returns 1\nincrement(String);            // 1\nincrement(Array);             // 1\nincrement(\"blabla\");          // 1\nincrement(\"-blabla\");         // 1\nincrement(0/0);               // 1\nincrement(\"0/0\");             // 1\nincrement(Infinity/Infinity); // 1\nincrement(NaN);               // 1\nincrement(undefined);         // 1\nincrement();                  // 1\n\n// isNaN(x) is always the same as isNaN(Number(x)),\n// but the presence of x is mandatory here!\nisNaN(x) == isNaN(Number(x)) // true for every value of x, including x == undefined,\n                             // because isNaN(undefined) == true and Number(undefined) returns NaN,\n                             // but ...\nisNaN() == isNaN(Number())   // false, because isNaN() == true and Number() == 0\nSpecifications\n \n  \n   Specification\n   Status\n   Comment\n  \n  \n   ECMAScript 1st Edition (ECMA-262)\n   Standard\n   Initial definition.\n  \n  \n   ECMAScript 5.1 (ECMA-262)The definition of 'isNaN' in that specification.\n   Standard\n   Â \n  \n  \n   ECMAScript 2015 (6th Edition, ECMA-262)The definition of 'isNaN' in that specification.\n   Standard\n   Â \n  \n \nBrowser compatibility \n     \n     \n        Desktop \n        Mobile \n     \n\n\n \n  \n   Feature\n   Chrome\n   Firefox (Gecko)\n   Internet Explorer\n   Opera\n   Safari\n  \n  \n   Basic support\n   (Yes)\n   (Yes)\n   (Yes)\n   (Yes)\n   (Yes)\n  \n \n\n\n\n \n  \n   Feature\n   Android\n   Chrome for Android\n   Firefox Mobile (Gecko)\n   IE Mobile\n   Opera Mobile\n   Safari Mobile\n  \n  \n   Basic support\n   (Yes)\n   (Yes)\n   (Yes)\n   (Yes)\n   (Yes)\n   (Yes)\n  \n \n\nSee also\n NaN\n Number.isNaN()\n",
    "syntax": "isNaN(testValue)",
    "prototypeProperties": {},
    "prototypeMethods": {},
    "constructorProperties": {},
    "constructorMethods": {}
  },
  "Error": {
    "shortDescription": "Runtime errors result in new Error objects being created and thrown.This page documents the use of the Error object itself and its use as a constructor function. For a list of properties and methods inherited by Error instances, see Error.prototype.",
    "syntax": "new Error([message[, fileName[, lineNumber]]])",
    "prototypeProperties": {
      "Error.prototype.constructor": "Specifies the function that created an instance's prototype.",
      "Error.prototype.message": "Error message.",
      "Error.prototype.name": "Error name.",
      "Error.prototype.description": "Error description. Similar to message.",
      "Error.prototype.number": "Error number.",
      "Error.prototype.fileName": "Path to file that raised this error.",
      "Error.prototype.lineNumber": "Line number in file that raised this error.",
      "Error.prototype.columnNumber": "Column number in line that raised this error.",
      "Error.prototype.stack": "Stack trace."
    },
    "prototypeMethods": {
      "Error.prototype.toSource()  ": "Returns a string containing the source of the specified Error object; you can use this value to create a new object. Overrides the Object.prototype.toSource() method.",
      "Error.prototype.toString()": "Returns a string representing the specified object. Overrides the Object.prototype.toString() method."
    },
    "constructorProperties": {
      "Error.prototype": "Allows the addition of properties to Error instances."
    },
    "constructorMethods": {}
  }
}